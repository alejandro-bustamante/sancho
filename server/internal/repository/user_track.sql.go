// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_track.sql

package repository

import (
	"context"
	"database/sql"
)

const addTrackToUser = `-- name: AddTrackToUser :exec
INSERT INTO user_track (user_id, track_id, symlink_path)
VALUES (?1, ?2, ?3)
`

type AddTrackToUserParams struct {
	UserID      sql.NullInt64 `json:"user_id"`
	TrackID     sql.NullInt64 `json:"track_id"`
	SymlinkPath string        `json:"symlink_path"`
}

func (q *Queries) AddTrackToUser(ctx context.Context, arg AddTrackToUserParams) error {
	_, err := q.exec(ctx, q.addTrackToUserStmt, addTrackToUser, arg.UserID, arg.TrackID, arg.SymlinkPath)
	return err
}

const countUsersForTrack = `-- name: CountUsersForTrack :one
SELECT COUNT(*) FROM user_track
WHERE track_id = ?1
`

func (q *Queries) CountUsersForTrack(ctx context.Context, trackID sql.NullInt64) (int64, error) {
	row := q.queryRow(ctx, q.countUsersForTrackStmt, countUsersForTrack, trackID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteUserTrack = `-- name: DeleteUserTrack :exec
DELETE FROM user_track
WHERE user_id = ?1 AND track_id = ?2
`

type DeleteUserTrackParams struct {
	UserID  sql.NullInt64 `json:"user_id"`
	TrackID sql.NullInt64 `json:"track_id"`
}

func (q *Queries) DeleteUserTrack(ctx context.Context, arg DeleteUserTrackParams) error {
	_, err := q.exec(ctx, q.deleteUserTrackStmt, deleteUserTrack, arg.UserID, arg.TrackID)
	return err
}

const getUserTrack = `-- name: GetUserTrack :one
SELECT user_id, track_id, symlink_path, linked_date FROM user_track
WHERE user_id = ?1 AND track_id = ?2
`

type GetUserTrackParams struct {
	UserID  sql.NullInt64 `json:"user_id"`
	TrackID sql.NullInt64 `json:"track_id"`
}

func (q *Queries) GetUserTrack(ctx context.Context, arg GetUserTrackParams) (UserTrack, error) {
	row := q.queryRow(ctx, q.getUserTrackStmt, getUserTrack, arg.UserID, arg.TrackID)
	var i UserTrack
	err := row.Scan(
		&i.UserID,
		&i.TrackID,
		&i.SymlinkPath,
		&i.LinkedDate,
	)
	return i, err
}

const isTrackLinkedToUserByUsernameAndISRC = `-- name: IsTrackLinkedToUserByUsernameAndISRC :one
SELECT EXISTS (
  SELECT 1
  FROM user_track ut
  JOIN track t ON ut.track_id = t.id
  JOIN user u ON ut.user_id = u.id
  WHERE u.username = ?1 AND t.isrc = ?2
)
`

type IsTrackLinkedToUserByUsernameAndISRCParams struct {
	Username string         `json:"username"`
	Isrc     sql.NullString `json:"isrc"`
}

func (q *Queries) IsTrackLinkedToUserByUsernameAndISRC(ctx context.Context, arg IsTrackLinkedToUserByUsernameAndISRCParams) (int64, error) {
	row := q.queryRow(ctx, q.isTrackLinkedToUserByUsernameAndISRCStmt, isTrackLinkedToUserByUsernameAndISRC, arg.Username, arg.Isrc)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
