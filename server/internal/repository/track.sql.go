// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: track.sql

package repository

import (
	"context"
	"database/sql"
)

const getAlbumByTrackID = `-- name: GetAlbumByTrackID :one
SELECT album.id, album.deezer_id, album.title, album.normalized_title, album.artist_id, album.release_date, album.album_art_path, album.genre, album.total_tracks, album.created_at FROM track
JOIN album ON track.album_id = album.id
WHERE track.id = ?1
`

func (q *Queries) GetAlbumByTrackID(ctx context.Context, trackID int64) (Album, error) {
	row := q.queryRow(ctx, q.getAlbumByTrackIDStmt, getAlbumByTrackID, trackID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.DeezerID,
		&i.Title,
		&i.NormalizedTitle,
		&i.ArtistID,
		&i.ReleaseDate,
		&i.AlbumArtPath,
		&i.Genre,
		&i.TotalTracks,
		&i.CreatedAt,
	)
	return i, err
}

const getArtistByTrackID = `-- name: GetArtistByTrackID :one
SELECT artist.id, artist.deezer_id, artist.name, artist.normalized_name, artist.created_at FROM track
JOIN artist ON track.artist_id = artist.id
WHERE track.id = ?1
`

func (q *Queries) GetArtistByTrackID(ctx context.Context, trackID int64) (Artist, error) {
	row := q.queryRow(ctx, q.getArtistByTrackIDStmt, getArtistByTrackID, trackID)
	var i Artist
	err := row.Scan(
		&i.ID,
		&i.DeezerID,
		&i.Name,
		&i.NormalizedName,
		&i.CreatedAt,
	)
	return i, err
}

const insertTrack = `-- name: InsertTrack :one
INSERT INTO track (
  title, normalized_title, artist_id, album_id, duration, track_number, disc_number,
  sample_rate, bitrate, channels, file_path, file_size, isrc, composer
) VALUES (
  ?1, ?2, ?3, 
  ?4, ?5, ?6,
  ?7, ?8, ?9,
  ?10, ?11, ?12,
  ?13, ?14
)
RETURNING id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bitrate, channels, file_path, file_size, isrc, composer, created_at
`

type InsertTrackParams struct {
	Title           string         `json:"title"`
	NormalizedTitle string         `json:"normalized_title"`
	ArtistID        sql.NullInt64  `json:"artist_id"`
	AlbumID         sql.NullInt64  `json:"album_id"`
	Duration        sql.NullInt64  `json:"duration"`
	TrackNumber     sql.NullInt64  `json:"track_number"`
	DiscNumber      sql.NullInt64  `json:"disc_number"`
	SampleRate      sql.NullInt64  `json:"sample_rate"`
	Bitrate         sql.NullInt64  `json:"bitrate"`
	Channels        sql.NullInt64  `json:"channels"`
	FilePath        string         `json:"file_path"`
	FileSize        sql.NullInt64  `json:"file_size"`
	Isrc            sql.NullString `json:"isrc"`
	Composer        sql.NullString `json:"composer"`
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) (Track, error) {
	row := q.queryRow(ctx, q.insertTrackStmt, insertTrack,
		arg.Title,
		arg.NormalizedTitle,
		arg.ArtistID,
		arg.AlbumID,
		arg.Duration,
		arg.TrackNumber,
		arg.DiscNumber,
		arg.SampleRate,
		arg.Bitrate,
		arg.Channels,
		arg.FilePath,
		arg.FileSize,
		arg.Isrc,
		arg.Composer,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.NormalizedTitle,
		&i.ArtistID,
		&i.AlbumID,
		&i.Duration,
		&i.TrackNumber,
		&i.DiscNumber,
		&i.SampleRate,
		&i.Bitrate,
		&i.Channels,
		&i.FilePath,
		&i.FileSize,
		&i.Isrc,
		&i.Composer,
		&i.CreatedAt,
	)
	return i, err
}

const listTracksByDate = `-- name: ListTracksByDate :many
SELECT id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bitrate, channels, file_path, file_size, isrc, composer, created_at FROM track ORDER BY created_at
`

func (q *Queries) ListTracksByDate(ctx context.Context) ([]Track, error) {
	rows, err := q.query(ctx, q.listTracksByDateStmt, listTracksByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.NormalizedTitle,
			&i.ArtistID,
			&i.AlbumID,
			&i.Duration,
			&i.TrackNumber,
			&i.DiscNumber,
			&i.SampleRate,
			&i.Bitrate,
			&i.Channels,
			&i.FilePath,
			&i.FileSize,
			&i.Isrc,
			&i.Composer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTracksByISRC = `-- name: SearchTracksByISRC :one
SELECT id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bitrate, channels, file_path, file_size, isrc, composer, created_at FROM track
WHERE isrc = ?1
LIMIT 1
`

func (q *Queries) SearchTracksByISRC(ctx context.Context, isrc sql.NullString) (Track, error) {
	row := q.queryRow(ctx, q.searchTracksByISRCStmt, searchTracksByISRC, isrc)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.NormalizedTitle,
		&i.ArtistID,
		&i.AlbumID,
		&i.Duration,
		&i.TrackNumber,
		&i.DiscNumber,
		&i.SampleRate,
		&i.Bitrate,
		&i.Channels,
		&i.FilePath,
		&i.FileSize,
		&i.Isrc,
		&i.Composer,
		&i.CreatedAt,
	)
	return i, err
}

const searchTracksByTitle = `-- name: SearchTracksByTitle :many
SELECT id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bitrate, channels, file_path, file_size, isrc, composer, created_at FROM track
WHERE LOWER(title) LIKE LOWER('%' || ?1 || '%')
ORDER BY title DESC
`

func (q *Queries) SearchTracksByTitle(ctx context.Context, title sql.NullString) ([]Track, error) {
	rows, err := q.query(ctx, q.searchTracksByTitleStmt, searchTracksByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.NormalizedTitle,
			&i.ArtistID,
			&i.AlbumID,
			&i.Duration,
			&i.TrackNumber,
			&i.DiscNumber,
			&i.SampleRate,
			&i.Bitrate,
			&i.Channels,
			&i.FilePath,
			&i.FileSize,
			&i.Isrc,
			&i.Composer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trackExistsByISRC = `-- name: TrackExistsByISRC :one
SELECT EXISTS (
  SELECT 1 FROM track WHERE isrc = ?1
)
`

func (q *Queries) TrackExistsByISRC(ctx context.Context, isrc sql.NullString) (int64, error) {
	row := q.queryRow(ctx, q.trackExistsByISRCStmt, trackExistsByISRC, isrc)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTrackFilePath = `-- name: UpdateTrackFilePath :exec
UPDATE track
SET file_path = ?1
WHERE id = ?2
`

type UpdateTrackFilePathParams struct {
	FilePath string `json:"file_path"`
	TrackID  int64  `json:"track_id"`
}

func (q *Queries) UpdateTrackFilePath(ctx context.Context, arg UpdateTrackFilePathParams) error {
	_, err := q.exec(ctx, q.updateTrackFilePathStmt, updateTrackFilePath, arg.FilePath, arg.TrackID)
	return err
}
