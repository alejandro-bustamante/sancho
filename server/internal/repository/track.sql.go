// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: track.sql

package repository

import (
	"context"
	"database/sql"
)

const insertTrack = `-- name: InsertTrack :one
INSERT INTO track (
  title, normalized_title, artist_id, album_id, duration, track_number, disc_number,
  sample_rate, bit_depth, bitrate, channels, codec,
  file_path, file_size, isrc
) VALUES (
  ?1, ?2, ?3, 
  ?4, ?5, ?6,
  ?7, ?8, ?9,
  ?10, ?11, ?12,
  ?13, ?14, ?15
)
RETURNING id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bit_depth, bitrate, channels, codec, file_path, file_size, isrc, created_at
`

type InsertTrackParams struct {
	Title           string         `json:"title"`
	NormalizedTitle string         `json:"normalized_title"`
	ArtistID        sql.NullInt64  `json:"artist_id"`
	AlbumID         sql.NullInt64  `json:"album_id"`
	Duration        sql.NullInt64  `json:"duration"`
	TrackNumber     sql.NullInt64  `json:"track_number"`
	DiscNumber      sql.NullInt64  `json:"disc_number"`
	SampleRate      sql.NullInt64  `json:"sample_rate"`
	BitDepth        sql.NullInt64  `json:"bit_depth"`
	Bitrate         sql.NullInt64  `json:"bitrate"`
	Channels        sql.NullInt64  `json:"channels"`
	Codec           sql.NullString `json:"codec"`
	FilePath        string         `json:"file_path"`
	FileSize        sql.NullInt64  `json:"file_size"`
	Isrc            sql.NullString `json:"isrc"`
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) (Track, error) {
	row := q.queryRow(ctx, q.insertTrackStmt, insertTrack,
		arg.Title,
		arg.NormalizedTitle,
		arg.ArtistID,
		arg.AlbumID,
		arg.Duration,
		arg.TrackNumber,
		arg.DiscNumber,
		arg.SampleRate,
		arg.BitDepth,
		arg.Bitrate,
		arg.Channels,
		arg.Codec,
		arg.FilePath,
		arg.FileSize,
		arg.Isrc,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.NormalizedTitle,
		&i.ArtistID,
		&i.AlbumID,
		&i.Duration,
		&i.TrackNumber,
		&i.DiscNumber,
		&i.SampleRate,
		&i.BitDepth,
		&i.Bitrate,
		&i.Channels,
		&i.Codec,
		&i.FilePath,
		&i.FileSize,
		&i.Isrc,
		&i.CreatedAt,
	)
	return i, err
}

const listTracksByDate = `-- name: ListTracksByDate :many
SELECT id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bit_depth, bitrate, channels, codec, file_path, file_size, isrc, created_at FROM track ORDER BY created_at
`

func (q *Queries) ListTracksByDate(ctx context.Context) ([]Track, error) {
	rows, err := q.query(ctx, q.listTracksByDateStmt, listTracksByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.NormalizedTitle,
			&i.ArtistID,
			&i.AlbumID,
			&i.Duration,
			&i.TrackNumber,
			&i.DiscNumber,
			&i.SampleRate,
			&i.BitDepth,
			&i.Bitrate,
			&i.Channels,
			&i.Codec,
			&i.FilePath,
			&i.FileSize,
			&i.Isrc,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTracksByTitle = `-- name: SearchTracksByTitle :many
SELECT id, title, normalized_title, artist_id, album_id, duration, track_number, disc_number, sample_rate, bit_depth, bitrate, channels, codec, file_path, file_size, isrc, created_at FROM track
WHERE LOWER(title) LIKE LOWER('%' || ?1 || '%')
ORDER BY title DESC
`

func (q *Queries) SearchTracksByTitle(ctx context.Context, title sql.NullString) ([]Track, error) {
	rows, err := q.query(ctx, q.searchTracksByTitleStmt, searchTracksByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Track{}
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.NormalizedTitle,
			&i.ArtistID,
			&i.AlbumID,
			&i.Duration,
			&i.TrackNumber,
			&i.DiscNumber,
			&i.SampleRate,
			&i.BitDepth,
			&i.Bitrate,
			&i.Channels,
			&i.Codec,
			&i.FilePath,
			&i.FileSize,
			&i.Isrc,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
